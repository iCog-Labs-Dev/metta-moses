;; Define Nat
(: Nat Type)
(: Z Nat)
(: S (-> Nat Nat))

;; Define cast functions between Nat and Number
(: fromNumber (-> Number Nat))
(= (fromNumber $n) (if (<= $n 0) Z (S (fromNumber (- $n 1)))))
(: fromNat (-> Nat Number))
(= (fromNat Z) 0)
(= (fromNat (S $k)) (+ 1 (fromNat $k)))

;;;;;;;;;;;;;;;;;;;;;
;; De Bruijn Index ;;
;;;;;;;;;;;;;;;;;;;;;

;; Define DeBruijn type
(: DeBruijn Type)

;; Define DeBruijn constructors
(: z DeBruijn)                        ; Zero
(: s (-> DeBruijn DeBruijn))          ; Successor
(: List (-> $a Type))
;; (: Nil (List $a))
;; (: Cons (-> $a (List $a) (List $a)))

;; Similar to match but takes a list of terms instead of a space.
(: match' (-> (List Atom) $a $a $a))
(= (match' Nil $pattern $rewrite) (empty))
(= (match' (Cons $head $tail) $pattern $rewrite) (let $pattern $head $rewrite))
(= (match' (Cons $head $tail) $pattern $rewrite) (match' $tail $pattern $rewrite))


;;;;;;;;;;;;;;;;;;;;;;
;; Backward chainer ;;
;;;;;;;;;;;;;;;;;;;;;;

;; Backward Chainer with environment.  There is no explicit support
;; for lambda abstraction due to the combinatorial explosion resulting
;; from combining lambda abstractions and applications.  Instead,
;; variables are added to the environment manually.  So for instance,
;; if the program to synthesize has the following type signature
;;
;; ğğ¨ğ¨ğ¥ -> ğğ¨ğ¨ğ¥ -> ğğ¨ğ¨ğ¥
;;
;; meaning it is a binary boolean function, thus has 2 arguments, we
;; add the following two declarations in the environment
;;
;; (: z ğğ¨ğ¨ğ¥)
;; (: (s z) ğğ¨ğ¨ğ¥)
;;
;; where z and (s z) represents the variables associated with the two
;; arguments.
;;
;; The arguments of the backward chainer are:
;;
;; * Knowledge base: reference to a space containing axioms and rules
;;   in the format (: <NAME> <RULE>).  Rules may or may not be curried
;;   depending on the convenience of the situation.
;;
;; * Environment: a list of typing relationships such as
;;
;;   (Cons (: z ğğ¨ğ¨ğ¥) (Cons (: (s z) ğğ¨ğ¨ğ¥) Nil))
;;
;; * Maximum depth: maximum depth of the generated proof tree.
;;
;; * Query: a metta term of the form (: <PROOF> <THEOREM>) where
;;   <PROOF> and <THEOREM> may contain free variables that may be
;;   filled by the backward chainer.
(: bc (-> $a                            ; Knowledge base space
          (List $b)                     ; Environment
          Nat                           ; Maximum depth
          $c                            ; Query
          $c))                          ; Result

;; Base cases
;; Match the knowledge base
(= (bc $kb $env $_ (: $prf $thrm))
   ;; (match $kb (: $prf $thrm) (if (< ((py-atom random.random)) 0.5) (empty) (: $prf $thrm) )))
   (match $kb (: $prf $thrm) (: $prf $thrm)))
;; Match the environment
(= (bc $kb $env $_ (: $prf $thrm))
   (match' $env (: $prf $thrm) (: $prf $thrm)))

;; Blackbox rule reduction
(= (bc $kb $env $_ (: ((CondReduce $p $r) $cnd) $thrm))
   (when (is-closed $cnd)
     (if (== ($p $cnd) $r) (: ((CondReduce $p $r) $cnd) $thrm) (empty))))

;; Recursive steps
;; Unary proof application
(= (bc $kb $env (S $k) (: ($prfabs $prfarg) $thrm))
   (let* (;; Recurse on unary rule
          ((: $prfabs (-> (: $prfarg $prms) $thrm))
           (bc $kb $env $k (: $prfabs (-> (: $prfarg $prms) $thrm))))
          ;; Recurse on premise
          ((: $prfarg $prms) (bc $kb $env $k (: $prfarg $prms))))
     (: ($prfabs $prfarg) $thrm)))
;; Binary proof application
(= (bc $kb $env (S $k) (: ($prfabs $prfarg1 $prfarg2) $thrm))
   (let* (;; Recurse on binary rule
          ((: $prfabs (-> (: $prfarg1 $prms1)
                          (: $prfarg2 $prms2)
                          $thrm))
           (bc $kb $env $k (: $prfabs (-> (: $prfarg1 $prms1)
                                          (: $prfarg2 $prms2)
                                          $thrm))))
          ;; Recurse on premise 1
          ((: $prfarg1 $prms1) (bc $kb $env $k (: $prfarg1 $prms1)))
          ;; Recurse on premise 2
          ((: $prfarg2 $prms2) (bc $kb $env $k (: $prfarg2 $prms2))))
     (: ($prfabs $prfarg1 $prfarg2) $thrm)))

!(bind! &rb (new-space))

;; Attempt to add more constraints on the reduct rules ;; WARN: This file isn't working yet.

;; ;; !(add-atom &rb (: CutOr (-> (: $x ğğ¨ğ¨ğ¥) (: ğ¨ğ« (-> (: $xs (List ğğ¨ğ¨ğ¥)) ğğ¨ğ¨ğ¥)) ğğ¨ğ¨ğ¥)))
;; !(add-atom &rb (: CutAnd (-> (: $x ğğ¨ğ¨ğ¥) (: ğšğ§ğ (-> (: $xs (List ğğ¨ğ¨ğ¥)) ğğ¨ğ¨ğ¥)) ğğ¨ğ¨ğ¥)))
;; !(add-atom &rb (: OrIden (-> (: $x ğğ¨ğ¨ğ¥) (: ğ¨ğ« (-> (: $xs (List ğğ¨ğ¨ğ¥)) ğğ¨ğ¨ğ¥)) ğğ¨ğ¨ğ¥)))
;; !(add-atom &rb (: AndIden (-> (: $x ğğ¨ğ¨ğ¥) (: ğšğ§ğ (-> (: $xs (List ğğ¨ğ¨ğ¥)) ğğ¨ğ¨ğ¥)) ğğ¨ğ¨ğ¥)))
;;
;; !(add-atom &rb (: CutOr (-> (: (ğ¨ğ« $x) ğğ¨ğ¨ğ¥) (: ğ¨ğ« (-> (: $xs (List ğğ¨ğ¨ğ¥)) ğğ¨ğ¨ğ¥)) (: ($rule $child ğšğ§ğ) ğğ¨ğ¨ğ¥)))) ;; return type should contain the resulting expression's type
;; !(add-atom &rb (: CutAnd (-> (: (ğšğ§ğ $x) ğğ¨ğ¨ğ¥) (: ğšğ§ğ (-> (: $xs (List ğğ¨ğ¨ğ¥)) ğğ¨ğ¨ğ¥)) (: ($rule $child ğ¨ğ«) ğğ¨ğ¨ğ¥))))
;; !(add-atom &rb (: OrIden (-> (: (ğ¨ğ« $x) ğğ¨ğ¨ğ¥) (: ğ¨ğ« (-> (: $xs (List ğğ¨ğ¨ğ¥)) ğğ¨ğ¨ğ¥)) (: ($rule $child ğšğ§ğ) ğğ¨ğ¨ğ¥))))
;; !(add-atom &rb (: AndIden (-> (: (ğšğ§ğ $x) ğğ¨ğ¨ğ¥) (: ğšğ§ğ (-> (: $xs (List ğğ¨ğ¨ğ¥)) ğğ¨ğ¨ğ¥)) (: ($rule $child ğ¨ğ«) ğğ¨ğ¨ğ¥))))


;; !(add-atom &rb (: CutOr (-> (: ((: $rule (-> (: (ğ¨ğ« $x) ğğ¨ğ¨ğ¥) ğğ¨ğ¨ğ¥)) $x) ğğ¨ğ¨ğ¥) ğğ¨ğ¨ğ¥)))
;; !(add-atom &rb (: CutOr (-> (: (ğ¨ğ« $x) ğğ¨ğ¨ğ¥) (: $rule (-> (: $nc ğğ¨ğ¨ğ¥) $nr)))))
;; !(add-atom &rb (: CutOr (-> (: $rule (-> (: (ğšğ§ğ $x) ğğ¨ğ¨ğ¥) (: (ğ¨ğ« $x') ğğ¨ğ¨ğ¥))) (: $rule (-> (: $nc ğğ¨ğ¨ğ¥) $nr)))))
;; !(add-atom &rb (: CutOr (-> (: (ğ¨ğ« $x) ğğ¨ğ¨ğ¥) (: $x ğğ¨ğ¨ğ¥))))
;; !(add-atom &rb (: CutOr (-> (: $rule (-> (: (ğšğ§ğ $x) ğğ¨ğ¨ğ¥) (: (ğ¨ğ« $x) ğğ¨ğ¨ğ¥))) (: $x ğğ¨ğ¨ğ¥))))

;; !(add-atom &rb (: CutAnd (-> (: (ğšğ§ğ $x) ğğ¨ğ¨ğ¥) (: $rule (-> (: $nc ğğ¨ğ¨ğ¥) $nr)))))
;; !(add-atom &rb (: CutAnd (-> (: $rule (-> (: (ğ¨ğ« $x) ğğ¨ğ¨ğ¥) (: (ğšğ§ğ $x') ğğ¨ğ¨ğ¥))) (: $rule (-> (: $nc ğğ¨ğ¨ğ¥) $nr)))))
;; !(add-atom &rb (: CutAnd (-> (: (ğšğ§ğ $x) ğğ¨ğ¨ğ¥) (: $x ğğ¨ğ¨ğ¥))))
;; !(add-atom &rb (: CutAnd (-> (: $rule (-> (: (ğ¨ğ« $x) ğğ¨ğ¨ğ¥) (: (ğšğ§ğ $x) ğğ¨ğ¨ğ¥))) (: $x ğğ¨ğ¨ğ¥))))
;; !(add-atom &rb (: OrIden (-> (: (ğ¨ğ« $x) ğğ¨ğ¨ğ¥) ğğ¨ğ¨ğ¥)))
;; !(add-atom &rb (: AndIden (-> (: (ğšğ§ğ $x) ğğ¨ğ¨ğ¥) ğğ¨ğ¨ğ¥)))


;; Run the code if the condition is true, otherwise prune the branch
(: when (-> Bool $a $a))
(= (when $c $x) (if $c $x (empty)))

;; Return True iff $term is closed
(: is-closed (-> Atom Bool))
(= (is-closed $term)
   (case (get-metatype $term)
     ((Variable False)
      (Symbol True)
      (Grounded True)
      (Expression (if (== $term ())
                      True
                      (let* (($head (car-atom $term))
                             ($tail (cdr-atom $term)))
                        (and (is-closed $head) (is-closed $tail))))))))

(: any (-> (List ğğ¨ğ¨ğ¥) ğğ¨ğ¨ğ¥))
(= (any Nil) ğ…ğšğ¥ğ¬ğ)
(= (any (Cons $x $xs)) (if (== $x ğ“ğ«ğ®ğ) ğ“ğ«ğ®ğ (any $xs)) )
;; (= (any (Cons $x $xs)) (trace! (Running X: $x check...) (if (== $x ğ“ğ«ğ®ğ) ğ“ğ«ğ®ğ (any $xs))) )

(: all (-> (List $a) ğğ¨ğ¨ğ¥))
(= (all Nil) ğ“ğ«ğ®ğ)
(= (all (Cons $x $xs)) (if (== $x ğ…ğšğ¥ğ¬ğ) ğ…ğšğ¥ğ¬ğ (all $xs)))
;; (= (all (Cons $x $xs)) (trace! (Running X: $x check...) (if (== $x ğ…ğšğ¥ğ¬ğ) ğ…ğšğ¥ğ¬ğ (all $xs))))

;; !(add-atom &rb (: ğšğ§ğ (-> (: $x (List ğğ¨ğ¨ğ¥)) ğğ¨ğ¨ğ¥)))
;; !(add-atom &rb (: ğ¨ğ« (-> (: $x (List ğğ¨ğ¨ğ¥)) ğğ¨ğ¨ğ¥)))

!(add-atom &rb (: CutOr (-> (: (ğ¨ğ« (Cons $x Nil)) ğğ¨ğ¨ğ¥) (: $x ğğ¨ğ¨ğ¥))))
!(add-atom &rb (: CutOr (-> (: ($rule $seq) (: (ğ¨ğ« (Cons $x Nil)) ğğ¨ğ¨ğ¥)) (: $x ğğ¨ğ¨ğ¥))))

!(add-atom &rb (: CutAnd (-> (: (ğšğ§ğ (Cons $x Nil)) ğğ¨ğ¨ğ¥) (: $x ğğ¨ğ¨ğ¥))))
!(add-atom &rb (: CutAnd (-> (: ($rule $seq) (: (ğšğ§ğ (Cons $x Nil)) ğğ¨ğ¨ğ¥)) (: $x ğğ¨ğ¨ğ¥))))

;; !(add-atom &rb (: OrIden (-> (: (ğ¨ğ« $xs) ğğ¨ğ¨ğ¥) (: (if (== (any $xs) ğ“ğ«ğ®ğ) ğ“ğ«ğ®ğ (empty)) ğğ¨ğ¨ğ¥)))) ;; FIX: Rule runs before candidate is closed.
;; !(add-atom &rb (: OrIden (-> (: ($rule $seq) (: (ğ¨ğ« $xs) ğğ¨ğ¨ğ¥)) (: (if (== (any $xs) ğ“ğ«ğ®ğ) ğ“ğ«ğ®ğ (empty)) ğğ¨ğ¨ğ¥))))
;; !(add-atom &rb (: OrIden (-> (: (ğ¨ğ« $xs) ğğ¨ğ¨ğ¥) (: ((CondReduce any ğ“ğ«ğ®ğ) $xs) ğğ¨ğ¨ğ¥)))) ;; FIX: Not working
;; !(add-atom &rb (: OrIden (-> (: ($rule $seq) (: (ğ¨ğ« $xs) ğğ¨ğ¨ğ¥)) (: ((CondReduce any ğ“ğ«ğ®ğ) $xs) ğğ¨ğ¨ğ¥))))

;; !(add-atom &rb (: AndIden (-> (: (ğšğ§ğ $xs) ğğ¨ğ¨ğ¥) (: (if (== (all $xs) ğ“ğ«ğ®ğ) (empty) ğ…ğšğ¥ğ¬ğ) ğğ¨ğ¨ğ¥))))
;; !(add-atom &rb (: AndIden (-> (: ($rule $seq) (: (ğšğ§ğ $xs) ğğ¨ğ¨ğ¥)) (: (if (== (all $xs) ğ“ğ«ğ®ğ) (empty) ğ…ğšğ¥ğ¬ğ) ğğ¨ğ¨ğ¥))))
;; !(add-atom &rb (: AndIden (-> (: (ğšğ§ğ $xs) ğğ¨ğ¨ğ¥) (: ((CondReduce all ğ…ğšğ¥ğ¬ğ) $xs) ğğ¨ğ¨ğ¥)))) ;; FIX: Not working
;; !(add-atom &rb (: AndIden (-> (: ($rule $seq) (: (ğšğ§ğ $xs) ğğ¨ğ¨ğ¥)) (: ((CondReduce all ğ…ğšğ¥ğ¬ğ) $xs) ğğ¨ğ¨ğ¥))))


!(add-atom &rb (: Id (-> (: $x ğğ¨ğ¨ğ¥) (: $x ğğ¨ğ¨ğ¥))))

!(add-atom &rb (: AndIden (-> (: (ğšğ§ğ $xs) ğğ¨ğ¨ğ¥) (: ((CondReduce all ğ…ğšğ¥ğ¬ğ) $xs) ğğ¨ğ¨ğ¥) (: ğ…ğšğ¥ğ¬ğ ğğ¨ğ¨ğ¥))))
!(add-atom &rb (: AndIden (-> (: ($rule $seq) (: (ğšğ§ğ $xs) ğğ¨ğ¨ğ¥)) (: ((CondReduce all ğ…ğšğ¥ğ¬ğ) $xs) ğğ¨ğ¨ğ¥) (: ğ…ğšğ¥ğ¬ğ ğğ¨ğ¨ğ¥))))

!(add-atom &rb (: OrIden (-> (: (ğ¨ğ« $xs) ğğ¨ğ¨ğ¥) (: ((CondReduce any ğ“ğ«ğ®ğ) $xs) ğğ¨ğ¨ğ¥) (: ğ“ğ«ğ®ğ ğğ¨ğ¨ğ¥))))
!(add-atom &rb (: OrIden (-> (: ($rule $seq) (: (ğ¨ğ« $xs) ğğ¨ğ¨ğ¥)) (: ((CondReduce any ğ“ğ«ğ®ğ) $xs) ğğ¨ğ¨ğ¥) (: ğ“ğ«ğ®ğ ğğ¨ğ¨ğ¥))))

!(println!
    (bc &rb
        ;; (Cons (: (ğ¨ğ« (Cons (ğšğ§ğ (Cons z Nil)) Nil)) ğğ¨ğ¨ğ¥) Nil) ;; CutOr and CutAnd
        ;; (Cons (: (ğ¨ğ« (Cons (ğšğ§ğ (Cons z (Cons ğ…ğšğ¥ğ¬ğ Nil))) Nil)) ğğ¨ğ¨ğ¥) Nil) ;; CutOr and CutAnd
        ;; (Cons (: (ğ¨ğ« (Cons (ğšğ§ğ (Cons z Nil)) (Cons ğ“ğ«ğ®ğ Nil))) ğğ¨ğ¨ğ¥) Nil) ;; IdentityOr
        ;; (Cons (: (ğ¨ğ« (Cons (ğšğ§ğ (Cons z (Cons ğ…ğšğ¥ğ¬ğ Nil))) Nil)) ğğ¨ğ¨ğ¥) Nil) ;; IdentityAnd
        ;; (Cons (: (ğ¨ğ« (Cons (ğšğ§ğ (Cons z (Cons ğ…ğšğ¥ğ¬ğ Nil))) Nil)) ğğ¨ğ¨ğ¥) Nil) ;; IdentityAnd
        ;; (Cons (: (ğ¨ğ« (Cons (ğšğ§ğ (Cons (ğ¨ğ« (Cons z Nil)) (Cons ğ…ğšğ¥ğ¬ğ Nil))) Nil)) ğğ¨ğ¨ğ¥) Nil) ;; IdentityAnd
        ;; (Cons (: (ğšğ§ğ (Cons (ğ¨ğ« (Cons z Nil)) (Cons ğ…ğšğ¥ğ¬ğ Nil))) ğğ¨ğ¨ğ¥) Nil) ;; IdentityAnd
        (Cons (: (ğšğ§ğ (Cons (ğ¨ğ« (Cons z Nil)) (Cons ğ“ğ«ğ®ğ Nil))) ğğ¨ğ¨ğ¥) Nil) ;; IdentityAnd
        ;; (Cons (: z ğğ¨ğ¨ğ¥) Nil)
        (fromNumber 2)
        (: $reduct (: $x ğğ¨ğ¨ğ¥)))
 )
