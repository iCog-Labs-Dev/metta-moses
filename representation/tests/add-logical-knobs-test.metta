; !(register-module! ../../../metta-moses)
; !(import! &self metta-moses:utilities:tree)
; !(import! &self metta-moses:utilities:list-methods)
; !(import! &self metta-moses:utilities:general-helpers)
; !(import! &self metta-moses:representation:knob-representation)
; !(import! &self metta-moses:representation:logical-probe)
; !(import! &self metta-moses:representation:knob-representation)
; !(import! &self metta-moses:representation:lsk)
; !(import! &self metta-moses:utilities:nodeId)
; !(import! &self metta-moses:representation:sample-logical-perms) 
; !(import! &self metta-moses:representation:add-logical-knobs)
; !(import! &self metta-moses:utilities:ordered-multimap) 
; !(import! &self metta-moses:utilities:lazy-random-selector)

; (= (ARGS) args) 
; (= (APPEND_CHILD $tree $nodeId $child ) (py_appendChild $tree $nodeId $child))
; (= (GetByID $tree $nodeId) (py_getById $tree $nodeId))

; ; ;; Testcase for the addLogicalKnobs 
; !(assertEqual (let* 
; (
;     (($updatedTree $mm) 
;      (addLogicalKnobs (mkTree (mkNode AND)     
;         (Cons (mkTree (mkNode A) Nil)
;           (Cons (mkTree (mkNode B) Nil) Nil)))
;               (mkNodeId (0)) True NilMMap))
;     (() (println! $updatedTree))
;     (() (println! $mm))
;     ($mmpsEqual 
;      (MultiMap.equals $mm 
;      (ConsMMap ((mkDiscSpec 3) (mkLSK (mkDiscKnob (mkKnob (mkNodeId (3))) (mkMultip 3) (mkDiscSpec 0) (mkDiscSpec 0) Nil) )) (ConsMMap ((mkDiscSpec 3) (mkLSK (mkDiscKnob (mkKnob (mkNodeId (4))) (mkMultip 3) (mkDiscSpec 0) (mkDiscSpec 0) Nil) )) (ConsMMap ((mkDiscSpec 3) (mkLSK (mkDiscKnob (mkKnob (mkNodeId (0 2))) (mkMultip 3) (mkDiscSpec 1) (mkDiscSpec 1) Nil) )) (ConsMMap ((mkDiscSpec 3) (mkLSK (mkDiscKnob (mkKnob (mkNodeId (0 1))) (mkMultip 3) (mkDiscSpec 1) (mkDiscSpec 1) Nil))) NilMMap))))))

;     ($treesEqual 
;      (== $updatedTree
;      (mkTree (mkNode AND) (Cons (mkTree (mkNode A) Nil) (Cons (mkTree (mkNode B) Nil) (Cons (mkNullVex (Cons (mkTree (mkNode OR) (Cons (mkTree (mkNode A) Nil) (Cons (mkTree (mkNode B) Nil) Nil))) Nil)) (Cons (mkNullVex (Cons (mkTree (mkNode OR) (Cons (mkTree (mkNode NOT) (Cons (mkTree (mkNode A) Nil) Nil)) (Cons (mkTree (mkNode B) Nil) Nil))) Nil)) Nil))))))
;     )
; )
; $mmpsEqual
; ) True)

; Testcase for the addLogicalKnobs 
; !(assertEqual (let* 
; (
;     (($updatedTree $mm) 
;      (addLogicalKnobs (mkTree (mkNode AND)     
;         (Cons (mkTree (mkNode A) Nil) 
;                (Cons (mkTree (mkNode OR)
;                   (Cons (mkTree (mkNode B) Nil)
;                   (Cons (mkTree (mkNode C) Nil) Nil)))Nil)))
;               (mkNodeId (2)) True NilMMap))
;     ($mmpsEqual 
;      (MultiMap.equals $mm 
; (ConsMMap ((mkDiscSpec 3) (mkLSK (mkDiscKnob (mkKnob (mkNodeId (2 5))) (mkMultip 3) (mkDiscSpec 0) (mkDiscSpec 0) Nil))) (ConsMMap ((mkDiscSpec 3) (mkLSK (mkDiscKnob (mkKnob (mkNodeId (2 4))) (mkMultip 3) (mkDiscSpec 0) (mkDiscSpec 0) Nil))) (ConsMMap ((mkDiscSpec 3) (mkLSK (mkDiscKnob (mkKnob (mkNodeId (2 1))) (mkMultip 3) (mkDiscSpec 1) (mkDiscSpec 1) Nil))) (ConsMMap ((mkDiscSpec 3) (mkLSK (mkDiscKnob (mkKnob (mkNodeId (2 3))) (mkMultip 3) (mkDiscSpec 0) (mkDiscSpec 0) Nil))) NilMMap))))
; ))
;     ($treesEqual 
;      (== $updatedTree
;       (mkTree (mkNode AND) (Cons (mkTree (mkNode A) Nil) (Cons (mkTree (mkNode OR) (Cons (mkTree (mkNode B) Nil) (Cons (mkTree (mkNode C) Nil) (Cons (mkNullVex (Cons (mkTree (mkNode A) Nil) Nil)) (Cons (mkNullVex (Cons (mkTree (mkNode AND) (Cons (mkTree (mkNode NOT) (Cons (mkTree (mkNode A) Nil) Nil)) (Cons (mkTree (mkNode B) Nil) Nil))) Nil)) (Cons (mkNullVex (Cons (mkTree (mkNode AND) (Cons (mkTree (mkNode A) Nil) (Cons (mkTree (mkNode B) Nil) Nil))) Nil)) Nil)))))) Nil))))))
; (== $mmpsEqual $treesEqual)
; )True)